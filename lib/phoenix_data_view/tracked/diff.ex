defmodule Phoenix.DataView.Tracked.Diff do
  alias Phoenix.DataView.Tracked

  @root_id {{__MODULE__, :internal, 0}, 0}

  # The set_fragment op replaces a fragment in its entirety.
  # Takes the fragment id, and the new data to replace it with.
  @op_set_fragment :s

  # The delete_fragment op instructs the client to delete the
  # given fragment from it's fragment cache.
  @op_delete_fragment :d

  # The patch op applies a patch to an existing fragment.
  # TODO these are generated by the second order diffing engine.
  @op_patch :p

  # The set_root op sets the given fragment id as the root.
  @op_set_root :f

  # Instructs the client to render it's state.
  # At this point, all child fragments of the root must be in the
  # clients fragment cache.
  @op_render :r

  def render_initial(tree, ids) do
    scopes_map =
      ids
      |> Enum.map(fn {k, _v} -> {k, %{values: %{}}} end)
      |> Enum.into(%{})
      |> Map.put(@root_id, %{values: %{}})

    ids = Map.put(ids, @root_id, %{num: -1, line: 0})

    state = %{
      generation: 0,
      ids: ids,
      scopes: scopes_map,
      next_alias: 1,
      aliases: %{},
      previous: nil
    }

    wrapper_tree = add_root_key(tree)
    {:ok, root, state} = traverse(wrapper_tree, state, &render_prepass_mapper/2)

    %Tracked.Ref{id: root_id, key: root_key} = root

    active = %{root => nil}
    active = add_active(state.scopes[root_id].values[root_key].value, active, state)
    state = assign_aliases(active, state)

    fragment_set_ops =
      Enum.map(active, fn {ref, nil} ->
        ref_alias = Map.fetch!(state.aliases, ref)
        fragment = state.scopes[ref.id].values[ref.key].value
        [@op_set_fragment, ref_alias, escape_fragment(fragment, state)]
      end)

    ops =
      fragment_set_ops ++
        [
          [@op_set_root, Map.fetch!(state.aliases, root)],
          [@op_render]
        ]

    {ops, state}
  end

  def render_diff(tree, state) do
    state = %{state | generation: state.generation + 1}

    wrapper_tree = add_root_key(tree)
    {:ok, root, state} = traverse(wrapper_tree, state, &render_prepass_mapper/2)

    %Tracked.Ref{id: root_id, key: root_key} = root

    active = %{root => nil}
    active = add_active(state.scopes[root_id].values[root_key].value, active, state)

    # TODO garbage collect state

    state = assign_aliases(active, state)

    fragment_set_ops =
      active
      |> Enum.map(fn {ref, nil} ->
        ref_alias = Map.fetch!(state.aliases, ref)
        data = state.scopes[ref.id].values[ref.key]

        if data.changed_generation == state.generation do
          [@op_set_fragment, ref_alias, escape_fragment(data.value, state)]
        else
          nil
        end
      end)
      |> Enum.filter(&(&1 != nil))

    # TODO minimize diffs

    ops =
      fragment_set_ops ++
        [
          [@op_render]
        ]

    {ops, state}
  end

  def add_root_key(tree) do
    %Tracked.Keyed{
      id: @root_id,
      key: 0,
      escapes: :always,
      render: fn -> tree end
    }
  end

  def escape_fragment(%Tracked.Ref{} = ref, state) do
    ["$r", Map.fetch!(state.aliases, ref)]
  end

  def escape_fragment(%_{}, _state) do
    raise "unreachable"
  end

  def escape_fragment(%{} = map, state) do
    map
    |> Enum.map(fn {k, v} ->
      {k, escape_fragment(v, state)}
    end)
    |> Enum.into(%{})
  end

  def escape_fragment(list, state) when is_list(list) do
    Enum.map(list, fn value -> escape_fragment(value, state) end)
  end

  def escape_fragment(atom, _mapper) when is_atom(atom), do: atom
  def escape_fragment(number, _mapper) when is_number(number), do: number
  def escape_fragment("$e", _mapper), do: ["$e", "$e"]
  def escape_fragment("$r", _mapper), do: ["$e", "$r"]
  def escape_fragment(binary, _mapper) when is_binary(binary), do: binary

  def assign_aliases(active, state) do
    Enum.reduce(active, state, fn {ref, nil}, state ->
      if Map.has_key?(state.aliases, ref) do
        state
      else
        %{
          state
          | aliases: Map.put(state.aliases, ref, state.next_alias),
            next_alias: state.next_alias + 1
        }
      end
    end)
  end

  def add_active(tree, acc, state) do
    {:ok, tree, new} =
      traverse(tree, %{}, fn %Tracked.Ref{} = ref, state ->
        state = Map.put(state, ref, nil)
        {:ok, nil, state}
      end)

    merged = Map.merge(acc, new)

    Enum.reduce(new, merged, fn {ref, nil}, acc ->
      add_active(state.scopes[ref.id].values[ref.key].value, acc, state)
    end)
  end

  def render_prepass_mapper(%Tracked.Cond{render: render}, state) do
    tree = render.()
    traverse(tree, state, &render_prepass_mapper/2)
  end

  def render_prepass_mapper(%Tracked.Keyed{} = keyed, state) do
    {keyed_mfa, _scope_subid} = keyed.id
    %{num: id, line: keyed_line} = Map.fetch!(state.ids, keyed.id)

    scope = Map.fetch!(state.scopes, keyed.id)
    item = Map.get(scope.values, keyed.key)

    false = Map.get(item || %{}, :in_stack, false)

    state =
      if needs_render?(item, keyed, state.generation) do
        state =
          update_in(state.scopes[keyed.id].values[keyed.key], fn prev ->
            prev ||
              %{generation: nil}
              |> Map.put(:in_stack, true)
          end)

        {:ok, value, state} = traverse(keyed.render.(), state, &render_prepass_mapper/2)

        update_in(state.scopes[keyed.id].values[keyed.key], fn item ->
          if debug_mode? and item.generation == state.generation and item.value != value do
            raise Tracked.KeyedException,
              mfa: keyed_mfa,
              line: keyed_line,
              previous: item.value,
              next: value
          end

          item
          |> Map.put(:in_stack, false)
          |> Map.put(:generation, state.generation)
          |> Map.put(:changed_generation, state.generation)
          |> Map.put(:value, value)
          |> Map.put(:escapes, keyed.escapes)
        end)
      else
        put_in(state.scopes[keyed.id].values[keyed.key].generation, state.generation)
      end

    ref = %Tracked.Ref{
      id: keyed.id,
      key: keyed.key
    }

    {:ok, ref, state}
  end

  def render_expand_mapper(%Tracked.Ref{} = ref, state) do
    inner = state.scopes[ref.id].values[ref.key].value
    traverse(inner, state, &render_expand_mapper/2)
  end

  # When there is no previous item, we always need to render.
  def needs_render?(nil = _item, _keyed, _current_generation), do: true
  # Behaviour on rerender within the same generation varies depending
  # on whether this is a debug build or not.
  # * In a debug build we do a rerender here. This allows us to validate
  #   that the user is consistent in their key => value mapping, and to
  #   throw an error when they are not. This is done to avoid hard-to-find
  #   bugs when a tracked function might not behave as they expect.
  # * In a production build we assume that any inconsistencies have been
  #   figured out in the dev environment. We don't render, and just use
  #   what was rendered previously within the same generation.
  def needs_render?(%{generation: gen}, _keyed, gen) do
    debug_mode?()
  end

  def needs_render?(%{escapes: :always}, %{escapes: :always}, _gen), do: true
  # The escapes are unchanged. No need to rerender.
  def needs_render?(%{escapes: escapes}, %{escapes: escapes}, _gen), do: false
  # Otherwise, we need to render.
  def needs_render?(_item, _keyed, _gen), do: true

  def expand(tree) do
    {:ok, out, nil} =
      traverse(tree, nil, fn
        %Tracked.Cond{render: render}, nil ->
          out = expand(render.())
          {:ok, out, nil}

        %Tracked.Keyed{render: render}, nil ->
          out = expand(render.())
          {:ok, out, nil}
      end)

    out
  end

  def traverse(%Tracked.Ref{} = op, state, mapper) do
    {:ok, value, state} = mapper.(op, state)
    {:ok, value, state}
  end

  def traverse(%Tracked.Cond{} = op, state, mapper) do
    {:ok, value, state} = mapper.(op, state)
    {:ok, value, state}
  end

  def traverse(%Tracked.Keyed{} = op, state, mapper) do
    {:ok, value, state} = mapper.(op, state)
    {:ok, value, state}
  end

  def traverse(%_{}, state, mapper) do
    raise ArgumentError, "structs are not supported by tracked functions"
  end

  def traverse(%{} = map, state, mapper) do
    {elems, state} =
      Enum.map_reduce(map, state, fn {key, value}, state ->
        if is_op?(key) do
          # TODO we don't even have a way to accomplish this for now, but there
          # are ways we can accomplish it. Do we even want to? Does it even make
          # sense?
          raise ArgumentError, "tracked ops may not be used directly in map keys"
        end

        {:ok, value, state} = traverse(value, state, mapper)
        {{key, value}, state}
      end)

    {:ok, Enum.into(elems, %{}), state}
  end

  def traverse(list, state, mapper) when is_list(list) do
    {list, state} =
      Enum.map_reduce(list, state, fn value, state ->
        {:ok, value, state} = traverse(value, state, mapper)
        {value, state}
      end)

    {:ok, list, state}
  end

  def traverse(tuple, state, mapper) when is_tuple(tuple) do
    {list, state} =
      tuple
      |> Tuple.to_list()
      |> Enum.map_reduce(state, fn value, state ->
        {:ok, value, state} = traverse(value, state, mapper)
        {value, state}
      end)

    {:ok, List.to_tuple(list), state}
  end

  def traverse(atom, state, _mapper) when is_atom(atom), do: {:ok, atom, state}
  def traverse(number, state, _mapper) when is_number(number), do: {:ok, number, state}
  def traverse(binary, state, _mapper) when is_binary(binary), do: {:ok, binary, state}

  def is_op?(%Tracked.Cond{}), do: true
  def is_op?(%Tracked.Keyed{}), do: true
  def is_op?(_value), do: false

  def debug_mode? do
    Application.get_env(:phoenix_data_view, :debug_mode, true)
  end
end
